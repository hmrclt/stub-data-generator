# Generating other kinds of data

The **smart-stub-generator** can produce a variety of other kinds of data including gendered names, email addresses, dates, uk addresses, postcodes,  and a very wide variety of reference numbers, NINOs and similar strings using the powerful concept of a pattern. These elements can then be combined to produce composite data structures such as case class representing a person with a forname, surname, date of birth, and a NINO.

## Gendered names

In the previous section we saw that it was possible to produce sensible looking names; but sometimes we need a plausible example of someone of a particular gender. For example, we would expect all mothers to be female. We can restrict forenames by genender in order to achieve this:

```scala
scala> import org.scalacheck._
import org.scalacheck._

scala> import hmrc.smartstub._
import hmrc.smartstub._

scala> val boy = Gen.forename(Male)
boy: org.scalacheck.Gen[String] = org.scalacheck.Gen$$anon$3@3ed2f74

scala> val girl = Gen.forename(Female)
girl: org.scalacheck.Gen[String] = org.scalacheck.Gen$$anon$3@650b942c

scala> s"${boy.sample.get} likes ${girl.sample.get}"
res0: String = Nathan likes Adalyn

scala> s"${girl.sample.get} likes ${boy.sample.get}"
res1: String = Victoria likes Grayson
```

## Email addresses

Email addresses can be produced on demand:

```scala
scala> import org.scalacheck._
import org.scalacheck._

scala> import hmrc.smartstub._
import hmrc.smartstub._

scala> //To be supplied
```

Sometimes it is useful to be able to relate the email to a name. In order to do this, you can include elements from names that _might_ be included

```scala
     | import org.scalacheck._
import org.scalacheck._

scala> import hmrc.smartstub._
import hmrc.smartstub._

scala> val firstNames = Gen.forename
firstNames: org.scalacheck.Gen[String] = org.scalacheck.Gen$$anon$3@17608849

scala> val lastNames = Gen.surname
lastNames: org.scalacheck.Gen[String] = org.scalacheck.Gen$$anon$1@7d6f84a3

scala> //get a single first and last name
     | val f = firstNames.sample.get
f: String = Elijah

scala> val l = lastNames.sample.get
l: String = Austin

scala> //To be supplied
     | //generate multiple emails based on that first and last name
     | //val emails = Gen.email(f, l)
     | //emails.sample.get
     | //emails.sample.get
```

## Dates

The dates we deal with are nearly always from the past; the dates generated by default by the **smart-stub-generator **extend from the 1st of January 1970 to the 31st of December 2001. This is intended to be suitable as a basic set of birthdates.

```scala
     | import org.scalacheck._
import org.scalacheck._

scala> import hmrc.smartstub._
import hmrc.smartstub._

scala> val dates = Gen.date(1970, 2000)
dates: org.scalacheck.Gen[java.time.LocalDate] = org.scalacheck.Gen$$anon$3@5643f6c8

scala> dates.sample.foreach{println}
1975-08-12
```

For dates in a wider range, simply supply the beginning and end year - these are inclusive so that if the firts year is 1935 and the end year is 2018, dates in either 1935 or 2018 could be generated.

```scala
scala> import org.scalacheck._
import org.scalacheck._

scala> import hmrc.smartstub._
import hmrc.smartstub._

scala> val dates = Gen.date(1935, 2018)
dates: org.scalacheck.Gen[java.time.LocalDate] = org.scalacheck.Gen$$anon$3@418992a3

scala> dates.sample.foreach{println}
1993-11-10
```

## UK Addresses

The addresses are currently uk personal addresses. The ```sample``` method has a type of ```Option[List[String]]```, so demontrating it needs a ```get``` and a ```map```.

```scala
scala> import org.scalacheck._
import org.scalacheck._

scala> import hmrc.smartstub._
import hmrc.smartstub._

scala> val addresses = Gen.ukAddress
addresses: org.scalacheck.Gen[List[String]] = org.scalacheck.Gen$$anon$3@1eb86a47

scala> addresses.sample.get.map{println}
45
Rossett Way
West London
W01 0EC
res11: List[Unit] = List((), (), (), ())
```

## Postcodes

To be supplied



## Patterns

To be supplied



## Composite data

Usually we are dealing with collections of very simple data to produce objects representing for example, businesses, people, organizations, and so on. In Scala, such collections are almost always represented by case classes. We can easily produce plausible examples of data in the case class form because the generators can be incuded in Scala's for comprehensions (e.g. they are monads.). 

Note how in the following example, the result of the forename generator is dependant on the result of the gender generator:

```scala
scala> import org.scalacheck._
import org.scalacheck._

scala> import hmrc.smartstub._
import hmrc.smartstub._

scala> case class Person(
     | gender: Gender,
     | name: String,
     | dateOfBirth: java.time.LocalDate,
     | address: List[String])
defined class Person

scala> val people: Gen[Person] = for {
     | gender <- Gen.gender
     | fname <- Gen.forename(gender)
     | sname <- Gen.surname
     | dob <- Gen.date(1935, 2000)
     | address <- Gen.ukAddress
     | } yield Person(gender, s"$fname $sname", dob, address)
people: org.scalacheck.Gen[Person] = org.scalacheck.Gen$$anon$3@74a4b5f7

scala> people.sample.get
res12: Person = Person(Female,Emma Troller,1975-01-06,List(76, Courageous Close, Paisley, PA94 4EC))
```



